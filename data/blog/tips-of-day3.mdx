---
title: ' چرخه حیات یک درخواست HTTP در Spring MVC'
date: '2024-01-01 3:00'
lastmod: '2024-01-01'
tags: ['اسپرینگ']
draft: false
summary: ''
images: []
---

### **چرخه حیات یک درخواست HTTP در Spring MVC**

در Spring MVC، هر درخواست HTTP مراحل مشخصی را طی می‌کند تا پردازش شود و یک پاسخ به کاربر بازگردانده شود. این مراحل شامل ورود درخواست به برنامه، پردازش توسط کنترلرها، و تولید پاسخ است. در ادامه به صورت جزئی مراحل چرخه حیات یک درخواست HTTP در Spring MVC توضیح داده شده است:

---

### **1. دریافت درخواست توسط سرور وب**

- **مرحله ورود به سرور:**
  - درخواست HTTP از کلاینت (مانند مرورگر) به وب‌سرور (مانند Apache Tomcat) ارسال می‌شود.
  - وب‌سرور درخواست را دریافت و آن را به برنامه Spring ارسال می‌کند.

---

### **2. عبور از Front Controller (DispatcherServlet)**

- **نقش DispatcherServlet:**
  - در Spring MVC، **DispatcherServlet** به عنوان Front Controller عمل می‌کند.
  - این Servlet وظیفه دریافت تمام درخواست‌ها و هدایت آنها به بخش‌های مناسب (مانند کنترلرها) را دارد.
  - مسیردهی درخواست‌ها بر اساس URL Mapping انجام می‌شود.

---

### **3. پردازش درخواست توسط HandlerMapping**

- **انتخاب کنترلر:**
  - **DispatcherServlet** از **HandlerMapping** برای تعیین اینکه کدام کنترلر باید درخواست را پردازش کند، استفاده می‌کند.
  - HandlerMapping با توجه به آدرس URL درخواست و مپینگ‌های تعریف‌شده در کنترلرها (مانند `@RequestMapping`) کنترلر مناسب را پیدا می‌کند.

---

### **4. فراخوانی کنترلر (Controller)**

- **اجرای متد کنترلر:**
  - **DispatcherServlet** کنترلر مشخص‌شده را فراخوانی می‌کند.
  - کنترلر در Spring معمولاً به صورت یک کلاس با انوتیشن `@Controller` یا `@RestController` تعریف می‌شود.
  - متدهای کنترلر با استفاده از انوتیشن‌هایی مانند `@RequestMapping`، `@GetMapping` یا `@PostMapping` مشخص می‌شوند.

---

### **5. پردازش منطق تجاری (Business Logic)**

- **تعامل با سرویس‌ها و لایه‌های داده:**
  - کنترلر معمولاً از کلاس‌های سرویس (Service Layer) برای پردازش منطق تجاری استفاده می‌کند.
  - در صورت نیاز به تعامل با پایگاه داده، کلاس‌های سرویس از Repositoryها یا DAOها استفاده می‌کنند.

---

### **6. بازگشت به DispatcherServlet**

- **برگرداندن نتیجه:**
  - کنترلر پس از اجرای منطق تجاری، یک شیء یا View را به **DispatcherServlet** بازمی‌گرداند.
  - اگر از `@ResponseBody` یا `@RestController` استفاده شود، داده‌ها به صورت JSON یا XML در پاسخ قرار می‌گیرند.

---

### **7. پردازش View توسط ViewResolver**

- **انتخاب View مناسب:**
  - اگر کنترلر یک View (مانند قالب HTML) را برگرداند، **ViewResolver** تعیین می‌کند که کدام فایل View باید برای تولید پاسخ استفاده شود.
  - فایل View ممکن است با استفاده از موتورهای قالب‌سازی مانند Thymeleaf، JSP یا FreeMarker تولید شود.

---

### **8. تولید پاسخ HTTP**

- **ایجاد پاسخ نهایی:**
  - **DispatcherServlet** پاسخ نهایی (مانند HTML، JSON، یا XML) را از View یا داده‌های بازگردانده‌شده توسط کنترلر تولید می‌کند.
  - این پاسخ به وب‌سرور بازگردانده می‌شود.

---

### **9. ارسال پاسخ به کلاینت**

- **بازگشت پاسخ به مرورگر:**
  - وب‌سرور پاسخ HTTP را به کلاینت بازمی‌گرداند.
  - کلاینت (مثلاً مرورگر) پاسخ را دریافت و به کاربر نمایش می‌دهد.

---

### **نمای کلی چرخه حیات**

1. درخواست به وب‌سرور ارسال می‌شود.
2. **DispatcherServlet** درخواست را دریافت می‌کند.
3. **HandlerMapping** کنترلر مناسب را پیدا می‌کند.
4. متد کنترلر اجرا می‌شود.
5. منطق تجاری پردازش می‌شود.
6. نتیجه به **DispatcherServlet** بازگردانده می‌شود.
7. **ViewResolver** View مناسب را پیدا می‌کند.
8. پاسخ نهایی تولید می‌شود.
9. پاسخ به کلاینت ارسال می‌شود.

---

### **مثال کد**

#### کنترلر:

```java
@RestController
@RequestMapping("/api")
public class UserController {

    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.getUserById(id); // تعامل با لایه سرویس
        return ResponseEntity.ok(user); // بازگرداندن پاسخ JSON
    }
}
```

#### کلاس سرویس:

```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User getUserById(Long id) {
        return userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
    }
}
```

#### Repository:

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```

---

### **نتیجه‌گیری**

چرخه حیات یک درخواست HTTP در Spring MVC به صورت سازمان‌دهی‌شده و ماژولار طراحی شده است. این ساختار باعث می‌شود توسعه‌دهندگان بتوانند به راحتی منطق تجاری، مسیریابی، و تولید پاسخ را مدیریت کنند. فهم دقیق این چرخه برای ایجاد برنامه‌های کارا و قابل‌اعتماد بسیار مهم است.
