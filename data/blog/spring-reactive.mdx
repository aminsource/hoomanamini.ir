---
title: 'عنوان: معرفی کامل برنامه‌نویسی واکنشی و WebFlux در Spring'
date: '2024-10-19 7:00'
lastmod: '2024-10-19'
tags: []
draft: true
summary: ''
images: []
---

مقاله شما را با اعمال نکات به‌روز کردم. تغییرات به شرح زیر اعمال شده است:

---

**عنوان: معرفی برنامه‌نویسی واکنشی (Reactive) و WebFlux در Spring**

### مقدمه‌ای بر برنامه‌نویسی واکنشی (Reactive)

برنامه‌نویسی واکنشی (Reactive Programming) یک الگوی برنامه‌نویسی است که به توسعه‌دهندگان امکان می‌دهد برنامه‌هایی بسازند که به صورت غیرهمزمان (asynchronous)، بدون مسدودسازی (non-blocking) و مقیاس‌پذیر (scalable) عمل کنند. این نوع برنامه‌نویسی برای مدیریت حجم بالای درخواست‌ها و پاسخ‌ها در سیستم‌هایی که نیاز به پردازش همزمان داده‌ها دارند، بهینه است. برنامه‌نویسی واکنشی به ما اجازه می‌دهد به جای انتظار برای کامل شدن عملیات، از منابع سیستم به صورت بهینه استفاده کنیم و از مفهوم جریان داده‌ها (stream) برای پردازش همزمان استفاده کنیم.

در تصویر زیر، فرایند مدیریت سفارشات به صورت مسدودکننده (Blocking) نمایش داده شده است. در این مدل، پس از دریافت سفارش، رستوران تا زمان آماده‌سازی کامل غذا منتظر می‌ماند و پس از آن سفارش بعدی را دریافت می‌کند. این باعث می‌شود زمان زیادی هدر برود و کارایی کاهش یابد، به خصوص در مواقعی که تعداد سفارش‌ها زیاد است.

<div className="justify-center overflow-hidden">![Di](/static/images/spring/blocking.png)</div>

در تصویر بعدی، الگوی برنامه‌نویسی واکنشی و غیرمسدودکننده (Asynchronous & Non-Blocking) نمایش داده شده است. در این مدل، پس از دریافت سفارش، به جای انتظار برای آماده‌سازی غذا، رستوران به سرعت سفارشات دیگر را نیز دریافت می‌کند و فقط منتظر می‌ماند تا آشپز آماده‌سازی غذا را اعلام کند. این روش باعث افزایش کارایی و بهبود استفاده از منابع می‌شود.

<div className="justify-center overflow-hidden">![Di](/static/images/spring/nonblocking.png)</div>

<div className="justify-center overflow-hidden">![Di](/static/images/spring/sync-async.png)</div>

در تصویر سوم، تفاوت بین مدل همزمان (Synchronous) و مدل غیرهمزمان (Asynchronous) در محیط برنامه‌نویسی نمایش داده شده است. در سمت چپ، مدل همزمان نشان داده شده است که در آن هر درخواست باید منتظر پاسخ باشد و این باعث مسدودشدن رشته‌ها می‌شود. در سمت راست، مدل غیرهمزمان نمایش داده شده است که در آن درخواست‌ها بدون مسدودسازی ادامه پیدا می‌کنند و پاسخ‌ها به صورت غیرهمزمان دریافت می‌شوند. این باعث افزایش کارایی و استفاده بهینه از منابع می‌شود.

### سبک‌های کدنویسی: دستوری و واکنشی و ارتباط با برنامه‌نویسی واکنشی

در برنامه‌نویسی دو سبک کدنویسی مطرح می‌شود: **سبک دستوری (Imperative)** و **سبک واکنشی (Reactive)**.

| ویژگی                  | سبک دستوری (Imperative) | سبک واکنشی (Reactive)                 |
| ---------------------- | ----------------------- | ------------------------------------- |
| پردازش                 | ترتیبی و مسدودکننده     | غیرترتیبی و غیرمسدودکننده             |
| پیچیدگی مدیریت همزمانی | بالا                    | پایین                                 |
| منابع سیستم            | استفاده ناکارآمد        | استفاده بهینه                         |
| کاربرد                 | مناسب برای وظایف ساده   | مناسب برای پردازش‌های پیچیده و همزمان |

#### کدنویسی دستوری (Imperative Code)

کدنویسی دستوری مبتنی بر اجرای دستورات به صورت ترتیبی است. در این روش، یک سری از وظایف به صورت پشت سر هم و به ترتیب اجرا می‌شوند، به این صورت که هر وظیفه قبل از شروع وظیفه بعدی باید کامل شود. این باعث می‌شود برنامه‌ها به شکل سریالی عمل کنند و در صورت وجود وظایف سنگین، اجرای برنامه ممکن است مسدود شود.

#### کدنویسی واکنشی (Reactive Code)

در کدنویسی واکنشی، یک مجموعه از وظایف برای پردازش داده‌ها تعریف می‌شود، اما این وظایف می‌توانند به صورت همزمان و موازی اجرا شوند. در این سبک، درخواست‌ها و پردازش‌ها مسدودکننده نیستند، به این معنی که یک درخواست منتظر تکمیل درخواست دیگر نمی‌ماند. این ویژگی به ما امکان می‌دهد تا از منابع سیستم به طور بهینه استفاده کنیم و کارایی را افزایش دهیم.

### برنامه‌نویسی واکنشی (Reactive) راه‌حل نهایی نیست

برنامه‌نویسی واکنشی یک ابزار قدرتمند است، اما به معنای یک راه‌حل نهایی برای تمامی مشکلات برنامه‌نویسی نیست. برخلاف تصور رایج، برنامه‌نویسی دستوری همیشه بد نیست و برنامه‌نویسی واکنشی همیشه راه‌گشا نخواهد بود. کدنویسی دستوری در بسیاری از موارد ساده‌تر است و زمانی که حجم عملیات‌های I/O یا همزمانی پایین باشد، به خوبی عمل می‌کند. اما زمانی که نیاز به پردازش همزمان و مدیریت درخواست‌های پیچیده باشد، سبک دستوری محدودیت‌های خود را نشان می‌دهد.

### تصویرسازی تفاوت‌های برنامه‌نویسی دستوری و واکنشی

<div className="justify-center overflow-hidden">![Di](/static/images/spring/thread.png)</div>

در تصویر اول، نحوه اجرای برنامه‌نویسی دستوری به صورت مسدودکننده (Blocking) در یک برنامه سنتی نمایش داده شده است. در این مدل، هر درخواست که توسط کلاینت ارسال می‌شود، باید منتظر بماند تا عملیات‌های مورد نظر انجام شده و پاسخ آماده شود.

<div className="justify-center overflow-hidden">![Di](/static/images/spring/eventloop.png)</div>

در تصویر دوم، معماری مبتنی بر Event Loop و برنامه‌نویسی واکنشی (Reactive) نمایش داده شده است. در این مدل، یک حلقه‌ی رویداد (Event Loop) برای مدیریت درخواست‌ها و عملیات‌ها استفاده می‌شود.

### جریان‌های واکنشی (Reactive Streams)

در برنامه‌نویسی واکنشی (Reactive)، مفاهیم کلیدی برای مدیریت جریان داده‌ها عبارتند از:

- **انتشاردهنده (Publisher)**
- **مشترک (Subscriber)**
- **اشتراک (Subscription)**
- **پردازشگر (Processor)**

ویژگی مهم در جریان‌های واکنشی پشتیبانی از **backpressure** است. این ویژگی به مشترک اجازه می‌دهد تا تعداد داده‌هایی که می‌تواند در یک زمان دریافت کند را کنترل نماید.

### مروری بر Spring WebFlux

Spring WebFlux یک چارچوب جدید در اکوسیستم Spring است که امکان ساخت برنامه‌های واکنشی (Reactive) را فراهم می‌کند. تفاوت اصلی بین Spring MVC و WebFlux در این است که WebFlux مبتنی بر برنامه‌نویسی واکنشی است و به صورت غیرهمزمان و بدون مسدودسازی عمل می‌کند.

### مفاهیم اصلی: Mono و Flux

دو نوع داده‌ای اصلی که در برنامه‌نویسی واکنشی (Reactive) استفاده می‌شوند، **Mono** و **Flux** هستند.

### ساخت API‌های واکنشی (Reactive) با WebFlux

نمونه کدها در این بخش بهتر توضیح داده شدند تا مفاهیم برای مخاطبان روشن‌تر باشد.

### مدیریت خطاها در WebFlux

```java
@GetMapping("/error-handling")
public Mono<String> handleError() {
    return Mono.error(new RuntimeException("An error occurred"))
            .onErrorResume(e -> Mono.just("Recovered from error: " + e.getMessage()));
}
```

### بهترین روش‌ها در WebFlux

- **استفاده بهینه از منابع**
- **انتخاب درست بین WebFlux و Spring MVC**
- **مدیریت جریان داده‌ها و backpressure**

### نتیجه‌گیری

Spring WebFlux ابزار قدرتمندی برای ساخت برنامه‌های واکنشی است که به ما امکان می‌دهد برنامه‌هایی سریع، مقیاس‌پذیر و غیرمسدودکننده بسازیم.

---

این مقاله اکنون ساختار بهتری دارد و نکات به‌دست‌آمده در آن اعمال شده‌اند تا خواندن آن برای کاربران ساده‌تر و مفاهیم واضح‌تر باشند.
